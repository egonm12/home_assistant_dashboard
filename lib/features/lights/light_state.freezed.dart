// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'light_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$GetLightStateTearOff {
  const _$GetLightStateTearOff();

  _GetLightStateInitial initial() {
    return const _GetLightStateInitial();
  }

  _GetLightStateInProgress inProgress() {
    return const _GetLightStateInProgress();
  }

  _GetLightStateSuccess success(LightStateModel lightState) {
    return _GetLightStateSuccess(
      lightState,
    );
  }

  _GetLightStateError error(String error) {
    return _GetLightStateError(
      error,
    );
  }
}

/// @nodoc
const $GetLightState = _$GetLightStateTearOff();

/// @nodoc
mixin _$GetLightState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetLightStateInitial value) initial,
    required TResult Function(_GetLightStateInProgress value) inProgress,
    required TResult Function(_GetLightStateSuccess value) success,
    required TResult Function(_GetLightStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetLightStateCopyWith<$Res> {
  factory $GetLightStateCopyWith(
          GetLightState value, $Res Function(GetLightState) then) =
      _$GetLightStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$GetLightStateCopyWithImpl<$Res>
    implements $GetLightStateCopyWith<$Res> {
  _$GetLightStateCopyWithImpl(this._value, this._then);

  final GetLightState _value;
  // ignore: unused_field
  final $Res Function(GetLightState) _then;
}

/// @nodoc
abstract class _$GetLightStateInitialCopyWith<$Res> {
  factory _$GetLightStateInitialCopyWith(_GetLightStateInitial value,
          $Res Function(_GetLightStateInitial) then) =
      __$GetLightStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$GetLightStateInitialCopyWithImpl<$Res>
    extends _$GetLightStateCopyWithImpl<$Res>
    implements _$GetLightStateInitialCopyWith<$Res> {
  __$GetLightStateInitialCopyWithImpl(
      _GetLightStateInitial _value, $Res Function(_GetLightStateInitial) _then)
      : super(_value, (v) => _then(v as _GetLightStateInitial));

  @override
  _GetLightStateInitial get _value => super._value as _GetLightStateInitial;
}

/// @nodoc

class _$_GetLightStateInitial implements _GetLightStateInitial {
  const _$_GetLightStateInitial();

  @override
  String toString() {
    return 'GetLightState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _GetLightStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetLightStateInitial value) initial,
    required TResult Function(_GetLightStateInProgress value) inProgress,
    required TResult Function(_GetLightStateSuccess value) success,
    required TResult Function(_GetLightStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _GetLightStateInitial implements GetLightState {
  const factory _GetLightStateInitial() = _$_GetLightStateInitial;
}

/// @nodoc
abstract class _$GetLightStateInProgressCopyWith<$Res> {
  factory _$GetLightStateInProgressCopyWith(_GetLightStateInProgress value,
          $Res Function(_GetLightStateInProgress) then) =
      __$GetLightStateInProgressCopyWithImpl<$Res>;
}

/// @nodoc
class __$GetLightStateInProgressCopyWithImpl<$Res>
    extends _$GetLightStateCopyWithImpl<$Res>
    implements _$GetLightStateInProgressCopyWith<$Res> {
  __$GetLightStateInProgressCopyWithImpl(_GetLightStateInProgress _value,
      $Res Function(_GetLightStateInProgress) _then)
      : super(_value, (v) => _then(v as _GetLightStateInProgress));

  @override
  _GetLightStateInProgress get _value =>
      super._value as _GetLightStateInProgress;
}

/// @nodoc

class _$_GetLightStateInProgress implements _GetLightStateInProgress {
  const _$_GetLightStateInProgress();

  @override
  String toString() {
    return 'GetLightState.inProgress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _GetLightStateInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return inProgress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return inProgress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetLightStateInitial value) initial,
    required TResult Function(_GetLightStateInProgress value) inProgress,
    required TResult Function(_GetLightStateSuccess value) success,
    required TResult Function(_GetLightStateError value) error,
  }) {
    return inProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
  }) {
    return inProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(this);
    }
    return orElse();
  }
}

abstract class _GetLightStateInProgress implements GetLightState {
  const factory _GetLightStateInProgress() = _$_GetLightStateInProgress;
}

/// @nodoc
abstract class _$GetLightStateSuccessCopyWith<$Res> {
  factory _$GetLightStateSuccessCopyWith(_GetLightStateSuccess value,
          $Res Function(_GetLightStateSuccess) then) =
      __$GetLightStateSuccessCopyWithImpl<$Res>;
  $Res call({LightStateModel lightState});

  $LightStateModelCopyWith<$Res> get lightState;
}

/// @nodoc
class __$GetLightStateSuccessCopyWithImpl<$Res>
    extends _$GetLightStateCopyWithImpl<$Res>
    implements _$GetLightStateSuccessCopyWith<$Res> {
  __$GetLightStateSuccessCopyWithImpl(
      _GetLightStateSuccess _value, $Res Function(_GetLightStateSuccess) _then)
      : super(_value, (v) => _then(v as _GetLightStateSuccess));

  @override
  _GetLightStateSuccess get _value => super._value as _GetLightStateSuccess;

  @override
  $Res call({
    Object? lightState = freezed,
  }) {
    return _then(_GetLightStateSuccess(
      lightState == freezed
          ? _value.lightState
          : lightState // ignore: cast_nullable_to_non_nullable
              as LightStateModel,
    ));
  }

  @override
  $LightStateModelCopyWith<$Res> get lightState {
    return $LightStateModelCopyWith<$Res>(_value.lightState, (value) {
      return _then(_value.copyWith(lightState: value));
    });
  }
}

/// @nodoc

class _$_GetLightStateSuccess implements _GetLightStateSuccess {
  const _$_GetLightStateSuccess(this.lightState);

  @override
  final LightStateModel lightState;

  @override
  String toString() {
    return 'GetLightState.success(lightState: $lightState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _GetLightStateSuccess &&
            const DeepCollectionEquality()
                .equals(other.lightState, lightState));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(lightState));

  @JsonKey(ignore: true)
  @override
  _$GetLightStateSuccessCopyWith<_GetLightStateSuccess> get copyWith =>
      __$GetLightStateSuccessCopyWithImpl<_GetLightStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return success(lightState);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return success?.call(lightState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(lightState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetLightStateInitial value) initial,
    required TResult Function(_GetLightStateInProgress value) inProgress,
    required TResult Function(_GetLightStateSuccess value) success,
    required TResult Function(_GetLightStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _GetLightStateSuccess implements GetLightState {
  const factory _GetLightStateSuccess(LightStateModel lightState) =
      _$_GetLightStateSuccess;

  LightStateModel get lightState;
  @JsonKey(ignore: true)
  _$GetLightStateSuccessCopyWith<_GetLightStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$GetLightStateErrorCopyWith<$Res> {
  factory _$GetLightStateErrorCopyWith(
          _GetLightStateError value, $Res Function(_GetLightStateError) then) =
      __$GetLightStateErrorCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$GetLightStateErrorCopyWithImpl<$Res>
    extends _$GetLightStateCopyWithImpl<$Res>
    implements _$GetLightStateErrorCopyWith<$Res> {
  __$GetLightStateErrorCopyWithImpl(
      _GetLightStateError _value, $Res Function(_GetLightStateError) _then)
      : super(_value, (v) => _then(v as _GetLightStateError));

  @override
  _GetLightStateError get _value => super._value as _GetLightStateError;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_GetLightStateError(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_GetLightStateError implements _GetLightStateError {
  const _$_GetLightStateError(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'GetLightState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _GetLightStateError &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$GetLightStateErrorCopyWith<_GetLightStateError> get copyWith =>
      __$GetLightStateErrorCopyWithImpl<_GetLightStateError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetLightStateInitial value) initial,
    required TResult Function(_GetLightStateInProgress value) inProgress,
    required TResult Function(_GetLightStateSuccess value) success,
    required TResult Function(_GetLightStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetLightStateInitial value)? initial,
    TResult Function(_GetLightStateInProgress value)? inProgress,
    TResult Function(_GetLightStateSuccess value)? success,
    TResult Function(_GetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _GetLightStateError implements GetLightState {
  const factory _GetLightStateError(String error) = _$_GetLightStateError;

  String get error;
  @JsonKey(ignore: true)
  _$GetLightStateErrorCopyWith<_GetLightStateError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$SetLightStateTearOff {
  const _$SetLightStateTearOff();

  _SetLightStateInitial initial() {
    return const _SetLightStateInitial();
  }

  _SetLightStateInProgress inProgress() {
    return const _SetLightStateInProgress();
  }

  _SetLightStateSuccess success(LightStateModel lightState) {
    return _SetLightStateSuccess(
      lightState,
    );
  }

  _SetLightStateError error(String error) {
    return _SetLightStateError(
      error,
    );
  }
}

/// @nodoc
const $SetLightState = _$SetLightStateTearOff();

/// @nodoc
mixin _$SetLightState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetLightStateInitial value) initial,
    required TResult Function(_SetLightStateInProgress value) inProgress,
    required TResult Function(_SetLightStateSuccess value) success,
    required TResult Function(_SetLightStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetLightStateCopyWith<$Res> {
  factory $SetLightStateCopyWith(
          SetLightState value, $Res Function(SetLightState) then) =
      _$SetLightStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SetLightStateCopyWithImpl<$Res>
    implements $SetLightStateCopyWith<$Res> {
  _$SetLightStateCopyWithImpl(this._value, this._then);

  final SetLightState _value;
  // ignore: unused_field
  final $Res Function(SetLightState) _then;
}

/// @nodoc
abstract class _$SetLightStateInitialCopyWith<$Res> {
  factory _$SetLightStateInitialCopyWith(_SetLightStateInitial value,
          $Res Function(_SetLightStateInitial) then) =
      __$SetLightStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$SetLightStateInitialCopyWithImpl<$Res>
    extends _$SetLightStateCopyWithImpl<$Res>
    implements _$SetLightStateInitialCopyWith<$Res> {
  __$SetLightStateInitialCopyWithImpl(
      _SetLightStateInitial _value, $Res Function(_SetLightStateInitial) _then)
      : super(_value, (v) => _then(v as _SetLightStateInitial));

  @override
  _SetLightStateInitial get _value => super._value as _SetLightStateInitial;
}

/// @nodoc

class _$_SetLightStateInitial implements _SetLightStateInitial {
  const _$_SetLightStateInitial();

  @override
  String toString() {
    return 'SetLightState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _SetLightStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetLightStateInitial value) initial,
    required TResult Function(_SetLightStateInProgress value) inProgress,
    required TResult Function(_SetLightStateSuccess value) success,
    required TResult Function(_SetLightStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _SetLightStateInitial implements SetLightState {
  const factory _SetLightStateInitial() = _$_SetLightStateInitial;
}

/// @nodoc
abstract class _$SetLightStateInProgressCopyWith<$Res> {
  factory _$SetLightStateInProgressCopyWith(_SetLightStateInProgress value,
          $Res Function(_SetLightStateInProgress) then) =
      __$SetLightStateInProgressCopyWithImpl<$Res>;
}

/// @nodoc
class __$SetLightStateInProgressCopyWithImpl<$Res>
    extends _$SetLightStateCopyWithImpl<$Res>
    implements _$SetLightStateInProgressCopyWith<$Res> {
  __$SetLightStateInProgressCopyWithImpl(_SetLightStateInProgress _value,
      $Res Function(_SetLightStateInProgress) _then)
      : super(_value, (v) => _then(v as _SetLightStateInProgress));

  @override
  _SetLightStateInProgress get _value =>
      super._value as _SetLightStateInProgress;
}

/// @nodoc

class _$_SetLightStateInProgress implements _SetLightStateInProgress {
  const _$_SetLightStateInProgress();

  @override
  String toString() {
    return 'SetLightState.inProgress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _SetLightStateInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return inProgress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return inProgress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetLightStateInitial value) initial,
    required TResult Function(_SetLightStateInProgress value) inProgress,
    required TResult Function(_SetLightStateSuccess value) success,
    required TResult Function(_SetLightStateError value) error,
  }) {
    return inProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
  }) {
    return inProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(this);
    }
    return orElse();
  }
}

abstract class _SetLightStateInProgress implements SetLightState {
  const factory _SetLightStateInProgress() = _$_SetLightStateInProgress;
}

/// @nodoc
abstract class _$SetLightStateSuccessCopyWith<$Res> {
  factory _$SetLightStateSuccessCopyWith(_SetLightStateSuccess value,
          $Res Function(_SetLightStateSuccess) then) =
      __$SetLightStateSuccessCopyWithImpl<$Res>;
  $Res call({LightStateModel lightState});

  $LightStateModelCopyWith<$Res> get lightState;
}

/// @nodoc
class __$SetLightStateSuccessCopyWithImpl<$Res>
    extends _$SetLightStateCopyWithImpl<$Res>
    implements _$SetLightStateSuccessCopyWith<$Res> {
  __$SetLightStateSuccessCopyWithImpl(
      _SetLightStateSuccess _value, $Res Function(_SetLightStateSuccess) _then)
      : super(_value, (v) => _then(v as _SetLightStateSuccess));

  @override
  _SetLightStateSuccess get _value => super._value as _SetLightStateSuccess;

  @override
  $Res call({
    Object? lightState = freezed,
  }) {
    return _then(_SetLightStateSuccess(
      lightState == freezed
          ? _value.lightState
          : lightState // ignore: cast_nullable_to_non_nullable
              as LightStateModel,
    ));
  }

  @override
  $LightStateModelCopyWith<$Res> get lightState {
    return $LightStateModelCopyWith<$Res>(_value.lightState, (value) {
      return _then(_value.copyWith(lightState: value));
    });
  }
}

/// @nodoc

class _$_SetLightStateSuccess implements _SetLightStateSuccess {
  const _$_SetLightStateSuccess(this.lightState);

  @override
  final LightStateModel lightState;

  @override
  String toString() {
    return 'SetLightState.success(lightState: $lightState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SetLightStateSuccess &&
            const DeepCollectionEquality()
                .equals(other.lightState, lightState));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(lightState));

  @JsonKey(ignore: true)
  @override
  _$SetLightStateSuccessCopyWith<_SetLightStateSuccess> get copyWith =>
      __$SetLightStateSuccessCopyWithImpl<_SetLightStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return success(lightState);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return success?.call(lightState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(lightState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetLightStateInitial value) initial,
    required TResult Function(_SetLightStateInProgress value) inProgress,
    required TResult Function(_SetLightStateSuccess value) success,
    required TResult Function(_SetLightStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _SetLightStateSuccess implements SetLightState {
  const factory _SetLightStateSuccess(LightStateModel lightState) =
      _$_SetLightStateSuccess;

  LightStateModel get lightState;
  @JsonKey(ignore: true)
  _$SetLightStateSuccessCopyWith<_SetLightStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SetLightStateErrorCopyWith<$Res> {
  factory _$SetLightStateErrorCopyWith(
          _SetLightStateError value, $Res Function(_SetLightStateError) then) =
      __$SetLightStateErrorCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$SetLightStateErrorCopyWithImpl<$Res>
    extends _$SetLightStateCopyWithImpl<$Res>
    implements _$SetLightStateErrorCopyWith<$Res> {
  __$SetLightStateErrorCopyWithImpl(
      _SetLightStateError _value, $Res Function(_SetLightStateError) _then)
      : super(_value, (v) => _then(v as _SetLightStateError));

  @override
  _SetLightStateError get _value => super._value as _SetLightStateError;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_SetLightStateError(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SetLightStateError implements _SetLightStateError {
  const _$_SetLightStateError(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'SetLightState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SetLightStateError &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$SetLightStateErrorCopyWith<_SetLightStateError> get copyWith =>
      __$SetLightStateErrorCopyWithImpl<_SetLightStateError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function(LightStateModel lightState) success,
    required TResult Function(String error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function(LightStateModel lightState)? success,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetLightStateInitial value) initial,
    required TResult Function(_SetLightStateInProgress value) inProgress,
    required TResult Function(_SetLightStateSuccess value) success,
    required TResult Function(_SetLightStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetLightStateInitial value)? initial,
    TResult Function(_SetLightStateInProgress value)? inProgress,
    TResult Function(_SetLightStateSuccess value)? success,
    TResult Function(_SetLightStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _SetLightStateError implements SetLightState {
  const factory _SetLightStateError(String error) = _$_SetLightStateError;

  String get error;
  @JsonKey(ignore: true)
  _$SetLightStateErrorCopyWith<_SetLightStateError> get copyWith =>
      throw _privateConstructorUsedError;
}
